// scripts/grammar-check.js
const fs = require('fs');
const path = require('path');

const TARGET_URL = process.env.TARGET_URL || '';
const CLIENT_ID  = process.env.CLIENT_ID  || '';
const AUDIT_TYPE = process.env.AUDIT_TYPE || 'single';
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

async function fetchHtml(url) {
  const r = await fetch(url, { redirect: 'follow' });
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  return await r.text();
}
function extractText(html) {
  return String(html)
    .replace(/<script[\s\S]*?<\/script>/gi, ' ')
    .replace(/<style[\s\S]*?<\/style>/gi, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

async function proofreadWithOpenAI(text, url) {
  if (!OPENAI_API_KEY) throw new Error('OPENAI_API_KEY not set');
  const MAX = 15000; // keep inputs modest; raise later if needed
  const body = {
    model: "gpt-4o-mini",
    instructions:
      "You are an expert copy editor. Find spelling/grammar/usage issues. " +
      "Return ONLY JSON matching the schema; give concise replacements.",
    input:
      `URL: ${url}\n\n` +
      `TEXT:\n${text.slice(0, MAX)}`,
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "GrammarAudit",
        schema: {
          type: "object",
          properties: {
            suggestions: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  issue:       { type: "string" },
                  original:    { type: "string" },
                  suggestion:  { type: "string" },
                  explanation: { type: "string" },
                  severity:    { type: "string", enum: ["low","medium","high"] }
                },
                required: ["issue","original","suggestion","explanation","severity"],
                additionalProperties: false
              }
            }
          },
          required: ["suggestions"],
          additionalProperties: false
        }
      }
    }
  };

  const r = await fetch("https://api.openai.com/v1/responses", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${OPENAI_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  if (!r.ok) throw new Error(`OpenAI HTTP ${r.status}`);
  const j = await r.json();

  // Prefer Responses API's unified text helper if present; else fall back safely
  const textOut = j.output_text || j.content?.[0]?.text || j.choices?.[0]?.message?.content || "";
  try { return JSON.parse(textOut); } catch { throw new Error("OpenAI did not return valid JSON"); }
}

(async () => {
  const outDir = path.join('out');
  fs.mkdirSync(outDir, { recursive: true });
  const t0 = Date.now();
  let result;

  try {
    const html = await fetchHtml(TARGET_URL);
    const text = extractText(html);
    const ai   = await proofreadWithOpenAI(text, TARGET_URL);

    result = {
      ok: true,
      client_id: CLIENT_ID,
      audit_type: AUDIT_TYPE,
      url: TARGET_URL,
      total_suggestions: Array.isArray(ai.suggestions) ? ai.suggestions.length : 0,
      suggestions: ai.suggestions || [],
      sample: text.slice(0, 300),
      duration_ms: Date.now() - t0
    };
  } catch (e) {
    result = {
      ok: false,
      client_id: CLIENT_ID,
      audit_type: AUDIT_TYPE,
      url: TARGET_URL,
      error: String(e && e.message || e),
      duration_ms: Date.now() - t0
    };
    process.exitCode = 1;
  }

  fs.writeFileSync(path.join(outDir, 'results.json'), JSON.stringify(result, null, 2));
  console.log('Wrote out/results.json');
})();
